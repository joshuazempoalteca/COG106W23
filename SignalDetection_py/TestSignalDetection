import numpy as np
import unittest
import matplotlib.pyplot as plt
import unittest

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm


import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
import math


class SignalDetection:
    def __init__(self, hits, misses, falseAlarms, correctRejections):
        self.hits = hits
        self.misses = misses
        self.falseAlarms = falseAlarms
        self.correctRejections = correctRejections

    def hit_rate(self):
        hit_rate = self.hits / (self.hits + self.misses)
        return hit_rate

    def FA(self):
        fa_rate = self.falseAlarms / (self.falseAlarms + self.correctRejections)
        return fa_rate

    def d_prime(self):
        hit_rate = self.hit_rate()
        fa_rate = self.FA()
        d_prime = norm.cdf(hit_rate) - norm.cdf(fa_rate)
        return d_prime

    def criterion(self):
        hit_rate = self.hit_rate()
        fa_rate = self.FA()
        return - (norm.cdf(hit_rate) + norm.cdf(fa_rate)) / 2

    def __add__(self, other):
        return SignalDetection(self.hits + other.hits, self.misses + other.misses, self.falseAlarms + other.falseAlarms, self.correctRejections + other.correctRejections)

    def __mul__(self, k):
        return SignalDetection(self.hits * k, self.misses * k, self.falseAlarms * k, self.correctRejections * k)

    def plot_sdt(self):
        x = np.linspace(-4, 4, 200)
        Noise = norm.pdf(x, 0, 1)
        Signal = norm.pdf(x, self.d_prime(), 1)

        plt.plot(x, Noise)
        plt.plot(x, Signal)
        plt.ylim([0, 0.5])
        plt.axvline((self.d_prime() / 2) + self.criterion(), linestyle='--', color='k')
        plt.plot([0, self.d_prime()], [np.max(Noise), np.max(Signal)])
        plt.legend(['Noise', 'Signal'])
        plt.show()

    def nLogLikelihood(self, hit_rate, false_alarm_rate):
        return - (self.hits * np.log(hit_rate) + self.misses * np.log(1-hit_rate) + self.falseAlarms * np.log(false_alarm_rate) + self.correctRejections * np.log(1-false_alarm_rate))

    @staticmethod
    def simulate(dprime, criteriaList, signalcount, noiseCount):
        sdtList = []
        for i in range(len(criteriaList)):
            k = criteriaList[i] + (dprime / 2)
            hit_rate = 1 - (norm.cdf(k - dprime))
            FA_rate = 1 - (norm.cdf(k))

            Hits = np.random.binomial(signalcount, hit_rate)
            Misses = signalcount - Hits
            fas = np.random.binomial(noiseCount, FA_rate)
            correct_Rejection = noiseCount - fas

            sdtList.append(SignalDetection(Hits, Misses, fas, correct_Rejection))
        return sdtList

    @staticmethod
    def plot_roc(sdtList):
        plt.figure()
        plt.plot([0, 1], [0, 1], '--', color=[0.5, 0.5, 0.5])
        plt.ylim([0, 1])
        plt.xlim([0, 1])
        plt.xlabel('False Alarm Rate')
        plt.ylabel('Hit Rate')
        plt.title('ROC Curve')
        for i in range(len(sdtList)):
            sdt = sdtList[i]
            plt.plot(sdt.FA(), sdt.hit_rate(), 'o')
        plt.show()



class TestSignalDetection(unittest.TestCase):
    """
    Test suite for SignalDetection class.
    """

    def test_d_prime_zero(self):
        """
        Test d-prime calculation when hits and false alarms are 0.
        """
        sd  = SignalDetection(15, 5, 15, 5)
        expected = 0
        obtained = sd.d_prime()
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_d_prime_nonzero(self):
        """
        Test d-prime calculation when hits and false alarms are nonzero.
        """
        sd   = SignalDetection(15, 10, 15, 5)
        expected = -0.421142647060282
        obtained = sd.d_prime()
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_criterion_zero(self):
        """
        Test criterion calculation when hits and false alarms are both 0.
        """
        sd   = SignalDetection(5, 5, 5, 5)
        expected = 0
        obtained = sd.criterion()
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_criterion_nonzero(self):
        """
        Test criterion calculation when hits and false alarms are nonzero.
        """
        sd   = SignalDetection(15, 10, 15, 5)
        expected = -0.463918426665941
        obtained = sd.criterion()
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_addition(self):
        """
        Test addition of two SignalDetection objects.
        """
        sd = SignalDetection(1, 1, 2, 1) + SignalDetection(2, 1, 1, 3)
        expected = SignalDetection(3, 2, 3, 4).criterion()
        obtained = sd.criterion()
        self.assertEqual(obtained, expected)

    def test_multiplication(self):
        """
        Test multiplication of a SignalDetection object with a scalar.
        """
        sd = SignalDetection(1, 2, 3, 1) * 4
        expected = SignalDetection(4, 8, 12, 4).criterion()
        obtained = sd.criterion()
        self.assertEqual(obtained, expected)

    def test_simulate_single_criterion(self):
        """
        Test SignalDetection.simulate method with a single criterion value.
        """
        dPrime       = 1.5
        criteriaList = [0]
        signalCount  = 1000
        noiseCount   = 1000
        
        sdtList      = SignalDetection.simulate(dPrime, criteriaList, signalCount, noiseCount)
        self.assertEqual(len(sdtList), 1)
        sdt = sdtList[0]
        
        self.assertEqual(sdt.hits             , sdtList[0].hits)
        self.assertEqual(sdt.misses           , sdtList[0].misses)
        self.assertEqual(sdt.falseAlarms      , sdtList[0].falseAlarms)
        self.assertEqual(sdt.correctRejections, sdtList[0].correctRejections)

    def test_simulate_multiple_criteria(self):
        """
        Test SignalDetection.simulate method with multiple criterion values.
        """
        dPrime       = 1.5
        criteriaList = [-0.5, 0, 0.5]
        signalCount  = 1000
        noiseCount   = 1000
        sdtList      = SignalDetection.simulate(dPrime, criteriaList, signalCount, noiseCount)
        self.assertEqual(len(sdtList), 3)
        for sdt in sdtList:
            self.assertLessEqual (sdt.hits              ,  signalCount)
            self.assertLessEqual (sdt.misses            ,  signalCount)
            self.assertLessEqual (sdt.falseAlarms       ,  noiseCount)
            self.assertLessEqual (sdt.correctRejections ,  noiseCount)
   
    def test_nLogLikelihood(self):
        """
        Test case to verify nLogLikelihood calculation for a SignalDetection object.
        """
        sdt = SignalDetection(10, 5, 3, 12)
        hit_rate = 0.5
        false_alarm_rate = 0.2
        expected_nll = - (10 * np.log(hit_rate) +
                           5 * np.log(1-hit_rate) +
                           3 * np.log(false_alarm_rate) +
                          12 * np.log(1-false_alarm_rate))
        self.assertAlmostEqual(sdt.nLogLikelihood(hit_rate, false_alarm_rate),
                               expected_nll, places=6)
        
    def test_rocLoss(self):
        """
        Test case to verify rocLoss calculation for a list of SignalDetection objects.
        """
        sdtList = [
            SignalDetection( 8, 2, 1, 9),
            SignalDetection(14, 1, 2, 8),
            SignalDetection(10, 3, 1, 9),
            SignalDetection(11, 2, 2, 8),
        ]
        a = 0
        expected = 99.3884
        self.assertAlmostEqual(SignalDetection.rocLoss(a, sdtList), expected, places=4)
        
    def test_integration(self):
        """
        Test case to verify integration of SignalDetection simulation and ROC fitting.
        """
        dPrime  = 1
        sdtList = SignalDetection.simulate(dPrime, [-1, 0, 1], 1e7, 1e7)
        aHat    = SignalDetection.fit_roc(sdtList)
        self.assertAlmostEqual(aHat, dPrime, places=2)
        plt.close()
        
if __name__ == '__main__':
    unittest.main()