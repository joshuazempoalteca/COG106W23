import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy.stats import norm
import math


class SignalDetection:
    def __init__(self, hits, misses, falseAlarms, correctRejections):
        self.hits = hits
        self.misses = misses
        self.falseAlarms = falseAlarms
        self.correctRejections = correctRejections

    def hit_rate(self):
        hit_rate = self.hits / (self.hits + self.misses)
        return hit_rate

    def FA(self):
        fa_rate = self.falseAlarms / (self.falseAlarms + self.correctRejections)
        return fa_rate

    def d_prime(self):
        hit_rate = self.hit_rate()
        fa_rate = self.FA()
        d_prime = norm.cdf(hit_rate) - norm.cdf(fa_rate)
        return d_prime

    def criterion(self):
        hit_rate = self.hit_rate()
        fa_rate = self.FA()
        return - (norm.cdf(hit_rate) + norm.cdf(fa_rate)) / 2

    def __add__(self, other):
        return SignalDetection(self.hits + other.hits, self.misses + other.misses, self.falseAlarms + other.falseAlarms, self.correctRejections + other.correctRejections)

    def __mul__(self, k):
        return SignalDetection(self.hits * k, self.misses * k, self.falseAlarms * k, self.correctRejections * k)

    def plot_sdt(self):
        x = np.linspace(-4, 4, 200)
        Noise = norm.pdf(x, 0, 1)
        Signal = norm.pdf(x, self.d_prime(), 1)

        plt.plot(x, Noise)
        plt.plot(x, Signal)
        plt.ylim([0, 0.5])
        plt.axvline((self.d_prime() / 2) + self.criterion(), linestyle='--', color='k')
        plt.plot([0, self.d_prime()], [np.max(Noise), np.max(Signal)])
        plt.legend(['Noise', 'Signal'])
        plt.show()
#new
    def nLogLikelihood(self, hit_rate, false_alarm_rate):
        nLogLikelihood = - (self.hits * np.log(hit_rate) + self.misses * np.log(1-hit_rate) + self.falseAlarms * np.log(false_alarm_rate) + self.correctRejections * np.log(1-false_alarm_rate))
        return nLogLikelihood

    @staticmethod
    def simulate(dprime, criteriaList, signalcount, noiseCount): #very similar to matlab code
        sdtList = []
        for i in range(len(criteriaList)):
            k = criteriaList[i] + (dprime / 2)
            hit_rate = 1 - (norm.cdf(k - dprime))
            FA_rate = 1 - (norm.cdf(k))

            hits = np.random.binomial(signalcount, hit_rate)
            misses = signalcount - hits

            fas = np.random.binomial(noiseCount, FA_rate)
            correct_Rejection = noiseCount - fas

            sdtList.append(SignalDetection(hits, misses, fas, correct_Rejection))
        return sdtList

    @staticmethod
    def plot_roc(sdtList):
        plt.figure()
        plt.plot([0, 1], [0, 1], '--', color=[0.5, 0.5, 0.5])
        plt.ylim([0, 1])
        plt.xlim([0, 1])
        plt.xlabel('False Alarm Rate')
        plt.ylabel('Hit Rate')
        plt.title('ROC Curve')
        for i in range(len(sdtList)):
            sdt = sdtList[i]
            plt.plot(sdt.FA(), sdt.hit_rate(), 'o')
        plt.show()

    @staticmethod
    def rocCurve(falseAlarmRate, a):
        # compute the predicted hit rate based on false alarm rate
        hitRate = scipy.stats.norm.cdf(
        a + scipy.stats.norm.ppf(falseAlarmRate))
        return (hitRate)

    @staticmethod
    def rocLoss(a, sdtList):
        # calculate the log-liklihood for each predicted hit rate to the observed false alarm rate
        loss = 0
        for sdt in sdtList:
            loss += sdt.nLogLikelihood(SignalDetection.rocCurve(
                sdt.false_alarm_rate, a), sdt.false_alarm_rate)
        return (loss)

    @staticmethod
    def fit_roc(sdtList):
        optimization_result = scipy.optimize.minimize(fun=SignalDetection.rocLoss, x0=0, args=(sdtList,))
        a_hat = optimization_result.x[0]
        falsesAlarms = np.arange(0, 1, 0.01)
        hitRates = SignalDetection.rocCurve(falsesAlarms, a_hat)
        
        plt.plot(falsesAlarms, hitRates, 'r')
        plt.xlabel("False Alarm Rate")
        plt.ylabel("Hit rate")
        plt.title("ROC curve")
        plt.show()
        return (a_hat)
        